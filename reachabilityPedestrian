% author Michael Hartmann (ESR 1)
% Researcher on safe automated vehicles for pedestrians
% dependencies:
% YALMIP
% MPT-Toolbox
% Please cite:  
% Hartmann, Michael (et. al.); "Pedestrians walking on reachable sets and
% manifolds"; IEEE 2019 International Conference on Mechatronics; 2019
function uncertaintyAnalysisWorstCase4Works()
set(0,'defaultAxesFontSize',22)
set(0,'defaultfigurecolor',[1 1 1])
set(0, 'DefaultLineLineWidth', 3);
close all
clear all
[params]=getparams();
actPosVeh=params.x0Veh(1:2);
myVehicle=[];
myVehicle.state=[params.x0Veh(1), params.x0Veh(3), 0];

NCircle=params.NCircle;

A=[0, 0, 1, 0, 0, 0;...
    0, 0, 0, 1, 0, 0;...
    0, 0, 0, 0, 1, 0;...
    0, 0, 0, 0, 0, 1;...
    0, 0, 0, 0, 0, 0;...
    0, 0, 0, 0, 0, 0];
B=[0, 0;...
    0, 0;...
    0, 0;...
    0, 0;...
    1, 0;...
    0, 1];
C=[1, 0, 0, 0, 0, 0;...
    0, 1, 0, 0, 0, 0];
D=zeros(2,2);
sys=ss(A, B, C, D);

A1=[0, 0, 1, 0;...
    0, 0, 0, 1;...
    0, 0, 0, 0;...
    0, 0, 0, 0];
B1=[0, 0;...
    0, 0;...
    1, 0;...
    0, 1];
C1=[1, 0, 0, 0;...
    0, 1, 0, 0];
D1=zeros(2,2);
sys1=ss(A1, B1, C1, D1);

A2=zeros(2,2);
B2=eye(2);
C2=eye(2);
D2=zeros(2,2);
sys2=ss(A2, B2, C2, D2);

time=linspace(0,params.T, params.T/params.Ts);
umax=params.umax;
amax=params.amax;
vmax=params.vmax;
yColl=zeros(length(time), 2, NCircle);
yColl2=zeros(length(time), 2, NCircle);
x0Ped=params.x0Ped;

dataColl=[];
dataColl.x_res=[];
dataColl.x_deriv_res=[];
dataColl.x_dderiv_res=[];

dataColl.ux_res=[];
dataColl.distanceLowerBound=[];
for cycle=1:3
    if(cycle==1)
        figure('units','normalized','outerposition',[0 0 1 1], 'Tag', '1')
    else
        allobj=findobj('Tag', '1');
        clf(allobj)
    end
    %close allobj;
    
    [PStreet]=visualizeStreet(params);
    for n=0:NCircle-1
        uxSquare=umax*sin(2*pi*n/NCircle);
        uySquare=umax*cos(2*pi*n/NCircle);
        u=[uxSquare*ones(1,length(time)); uySquare*ones(1,length(time))];
        [y,~,~] = lsim(sys, u, time, x0Ped);
        yColl(:,:, n+1)=y;
    end
    
    for n=0:NCircle-1
        axSquare=amax*sin(2*pi*n/NCircle);
        aySquare=amax*cos(2*pi*n/NCircle);
        u1=[axSquare*ones(1,length(time)); aySquare*ones(1,length(time))];
        [y,~,~] = lsim(sys1, u1, time, x0Ped(1:4));
        yColl1(:,:, n+1)=y;
    end
    
    for n=0:NCircle-1
        vxSquare=vmax*sin(2*pi*n/NCircle);
        vySquare=vmax*cos(2*pi*n/NCircle);
        u2=[vxSquare*ones(1,length(time)); vySquare*ones(1,length(time))];
        [y2,~,~] = lsim(sys2, u2, time, x0Ped(1:2));
        yColl2(:,:, n+1)=y2;
    end
    
    hold on
    
    
    [maxPoly1, ~, colIntersect]=visualizeIntersectionReachability(yColl, yColl1, yColl2, PStreet);
    plot(maxPoly1, 'r');
    grid on
    axis equal
    %set(gca,'XTick',[1:params.MAX_X])
    %set(gca,'YTick',[1:params.MAX_Y])
    xlabel('x [-]', 'FontSize', 26)
    ylabel('y [-]', 'FontSize', 26)
    cb=colorbar;
    set(cb, 'Ticks', linspace(0, params.T, 11))
    caxis([0, params.T])
    ylabel(cb, 'Future Time Horizon [s]')
    [x_res, x_deriv_res, ux_res, lowerBound]=mixedIntegerOpti(PStreet, maxPoly1, myVehicle, params);
    distanceLowerBound=lowerBound-x_res;
    title('Reachability analysis and optimal motion planning', 'FontSize', 26)
    visualizeVehicle(actPosVeh, 0, params, x_res);
    drawnow;
    pause(.05);
    myVehicle.state=[x_res(end), x_deriv_res(end), ux_res(end)];
    dataColl.x_res=[dataColl.x_res, x_res];
    dataColl.x_deriv_res=[dataColl.x_deriv_res, x_deriv_res];
    dataColl.ux_res=[dataColl.ux_res, ux_res];
    dataColl.distanceLowerBound=[dataColl.distanceLowerBound, distanceLowerBound];
    [x0Ped, trajPed]=changePedestrianBehavior(x0Ped, params, x_res);
    maxAChange=makePredictionWithGP(trajPed, params,colIntersect);
    if(maxAChange>params.ulowerBound)
        umax=maxAChange;
    else
        umax=params.ulowerBound;
    end
    if(cycle==1)
        waitforbuttonpress;
    end
end

visualizeExperiment(dataColl, params)

end

function maxAChange=makePredictionWithGP(trajPed, params, colIntersect)
difX=diff(trajPed(1,:));
difY=diff(trajPed(2,:));
XLearn=trajPed(:, 2:end);
gprMdlX = fitrgp(XLearn',difX');
gprMdlY = fitrgp(XLearn',difY');
edgePoints=extreme(colIntersect);
[X, Y]=meshgrid(linspace(params.streetXMin, params.streetXMax, 130), linspace(-10, 10, 40));
X=X(:);
Y=Y(:);
in=inpolygon(X, Y, edgePoints(:, 1), edgePoints(:, 2));
idx=find(in~=0);
X=X(idx);
Y=Y(idx);
predX=predict(gprMdlX, [X, Y]);
predY=predict(gprMdlY, [X, Y]);
quiver(X, Y, predX, predY, 0);
vel=sqrt(predX.^2+predY.^2);
maxVel=max(vel);


diffX=diff(difX);
diffY=diff(difY);
difffX=diff(diffX);
difffY=diff(diffY);
XLearn1=trajPed(:, 4:end);
gprMdlX = fitrgp(XLearn1',difffX');
gprMdlY = fitrgp(XLearn1',difffY');
predX=predict(gprMdlX, [X, Y]);
predY=predict(gprMdlY, [X, Y]);
aChange=sqrt(predX.^2+predY.^2);
maxAChange=max(aChange);

end

function [x0Ped, trajPed]=changePedestrianBehavior(x0Ped, params, x_res)
xdiff=params.average_veloc_ped*params.Ts;
xPedY=ones(1, length(x_res)).*x0Ped(2);

xPedX=[0:length(x_res)-1].*xdiff+x0Ped(1);
x0Ped(1)=x0Ped(1)+xPedX(end);
x0Ped(3)=x0Ped(3);
xPed=[xPedX; xPedY];
cmap=colormap('jet');
for wlt=1:length(xPedX)
    actCol=ceil((wlt/params.N)*(size(cmap, 1)-1));
    plot(xPedX(wlt), xPedY(wlt), '.', 'color', cmap(actCol, :), 'MarkerSize', 14);
end
trajPed=[xPedX; xPedY];
end

function visualizeExperiment(dataColl, params)
time=[1:length(dataColl.x_res)].*params.Ts;
%figure()
title('Optimization based motion planning', 'FontSize', 26)
subplot(3, 1, 1)
plot(time, dataColl.x_res)
xlabel('time t [s]', 'FontSize', 26)
ylabel('x [m]', 'FontSize', 26)
grid on
subplot(3, 1, 2)
plot(time, dataColl.x_deriv_res.*3.6)
xlabel('time t [s]', 'FontSize', 26)
ylabel('v_x [km/h]', 'FontSize', 26)
grid on
subplot(3, 1, 3)
plot(time, dataColl.ux_res)
xlabel('time t [s]', 'FontSize', 26)
ylabel('ux [N]', 'FontSize', 26)
grid on

end

function [x_res, x_deriv_res, ux_res, lowerBound]=mixedIntegerOpti(myStreet, pedestrian1, myVehicle, params)

extremePoints=extreme(pedestrian1);
exitYes=0;

initDat=myVehicle.state';


%% System-Dynamics
discSys = getSystemDynamics(params);


%% Yalmip variables

x       = sdpvar(1, params.N);
x_deriv = sdpvar(1, params.N);
ux      = sdpvar(1, params.N);


constraints=[x(1);x_deriv(1);ux(1)]==initDat;
constraints=[constraints; x_deriv<=params.vy_max*ones(1, params.N)];
constraints=[constraints; diff(x_deriv)<=params.diff_vy_max*ones(1, params.N-1)];
constraints=[constraints; -diff(x_deriv)<=params.diff_vy_max*ones(1, params.N-1)];
constraints=[constraints; ux<=params.Fy_max*ones(1, params.N)];
constraints=[constraints; -ux<=params.Fy_max*ones(1, params.N)];
constraints=[constraints; diff(ux)<=params.c*params.Fy_max*ones(1, params.N-1)];
constraints=[constraints; -diff(ux)<=params.c*params.Fy_max*ones(1, params.N-1)];
constraints=[constraints; x_deriv>=zeros(1, params.N)];

lowerBound=NaN;
for wlt=1:params.N-1
    if(~isempty(extremePoints))
        lowerBound=min(extremePoints(:, 1));
        constraints=[constraints; abs(x(wlt+1)-lowerBound)>=params.dist_safe];
    end
    constraints=[constraints, [x(wlt+1); x_deriv(wlt+1)]==discSys.a*[x(wlt); x_deriv(wlt)]+discSys.b*[ux(wlt)]];
end
%% Optimization with Yalmip
% $min_{x}(\underline{u}_x \cdot \textbf{1} + \underline{u}_y \cdot \textbf{1})$
options=sdpsettings('CACHESOLVER',1, 'solver', 'glpk');

%if(pedestrian1.willBeOnStreet==1)
% constraints=[constraints; x_deriv(end)<=1.389];
%end

objectiveFunction = -x(end);

%optimize(constraints, objectiveFunction, options)

diagnostics=optimize(constraints, objectiveFunction, options);
if diagnostics.problem == 0
    disp('Solver thinks it is feasible')
elseif diagnostics.problem == 1
    disp('Solver thinks it is infeasible')
    exitYes=1;
else
    disp('Something else happened')
end

x_res=value(x);
x_res=x_res(2:params.nu+1);
x_deriv_res=value(x_deriv);
x_deriv_res=x_deriv_res(2:params.nu+1);
ux_res=value(ux);
ux_res=ux_res(2:params.nu+1);


end


function [maxPoly1, maxPolyStat, colIntersect]=visualizeIntersectionReachability(yColl, yColl1, yColl2, PStreet)
cmap=colormap('jet');
criticalPoly=[];
maxPoly=polytope();
for wlt=2:size(yColl1, 1)
    actCol=ceil((wlt/size(yColl1, 1))*(size(cmap, 1)-1));
    colA=yColl(wlt,:,:);
    colB=yColl1(wlt,:,:);
    colC=yColl2(wlt,:,:);
    colA=permute(colA, [2, 3, 1])';
    colB=permute(colB, [2, 3, 1])';
    colC=permute(colC, [2, 3, 1])';
    colA=polytope(colA);
    colB=polytope(colB);
    colC=polytope(colC);
    colIntersect=intersect(colA, colB);
    colIntersect=intersect(colIntersect, colC);
    Options.edgecolor=cmap(actCol, :);
    Options.wire=1;
    Options.linewidth=2;
    plot(colIntersect, Options)
    actCriticalPoly=intersect(colIntersect, PStreet);
    criticalPoly=[criticalPoly, {actCriticalPoly}];
    maxPoly=[maxPoly, actCriticalPoly];
    %actIntersectVert=colIntersect.V;
    %D=pdist2(actIntersectVert,actIntersectVert);
    %[~, idxMat]=sort(D, 1);
    %vecIdx=idxMat(2,:)';
    %plot([actIntersectVert(:, 1), actIntersectVert(vecIdx, 1)], [actIntersectVert(:, 2), actIntersectVert(vecIdx, 2)], '-', 'Color', cmap(actCol, :), 'LineWidth', 3)
end
maxPoly1=union(maxPoly);
extreMaxPoly1=extreme(maxPoly1);
if(~isempty(extreMaxPoly1))
    maxPolyY=max(extreMaxPoly1(:, 2));
    A=polyarea(extreMaxPoly1(:,1), extreMaxPoly1(:, 2));
    maxPolyStat.maxPolyA=A;
    maxPolyStat.maxPolyY=maxPolyY;
else
    maxPolyStat.maxPolyA=0;
    maxPolyStat.maxPolyY=Inf;
end
end

function visualizeVehicle(actPosVeh, actOrientVeh, params, xVeh)
polyVeh=[-params.vehicleLength/2, -params.vehicleWidth/2, 1;...
    params.vehicleLength/2, -params.vehicleWidth/2, 1;...
    params.vehicleLength/2, params.vehicleWidth/2, 1;...
    -params.vehicleLength/2, params.vehicleWidth/2, 1];
RotMat=[cosd(-actOrientVeh), sind(-actOrientVeh), actPosVeh(1);...
    -sind(-actOrientVeh), cosd(-actOrientVeh), actPosVeh(2);...
    0, 0, 1];
polyVehTz=RotMat*polyVeh';
polyVehTz=polyVehTz(1:2,:)';
PVehicle=Polyhedron(polyVehTz);
plot(PVehicle, 'color', [0.9, .9, .1], 'Alpha', 1);
cmap=colormap('jet');
for wlt=1:length(xVeh)
    polyVeh=[-params.vehicleLength/2, -params.vehicleWidth/2, 1;...
        params.vehicleLength/2, -params.vehicleWidth/2, 1;...
        params.vehicleLength/2, params.vehicleWidth/2, 1;...
        -params.vehicleLength/2, params.vehicleWidth/2, 1];
    actCol=ceil((wlt/params.N)*(size(cmap, 1)-1));
    RotMat=[cosd(-actOrientVeh), sind(-actOrientVeh), xVeh(wlt);...
        -sind(-actOrientVeh), cosd(-actOrientVeh), actPosVeh(2);...
        0, 0, 1];
    polyVeh=RotMat*polyVeh';
    polyVeh=polyVeh(1:2,:)';
    PVehicle=Polyhedron(polyVeh);
    plot(PVehicle, 'color', cmap(actCol, :), 'Alpha', 1);
end
end

function [PStreet]=visualizeStreet(params)
hold on
ASidewalk1=[eye(2); -eye(2)];
bSidewalk1=[params.streetXMax;0;-params.streetXMin;5];
PSidewalk1=Polyhedron(ASidewalk1,bSidewalk1);
plot(PSidewalk1, 'Color', [.1,.6, .1], 'Alpha', .1);

AStreet=[eye(2); -eye(2)];
bStreet=[params.streetXMax;5.5;-params.streetXMin;0];
PStreet=polytope(AStreet,bStreet);
Options.color=[.1,.1, .1];
Options.shade=.1;
plot(PStreet, Options);

ASidewalk2=[eye(2); -eye(2)];
bSidewalk2=[params.streetXMax;10.5;-params.streetXMin;-5.5];
PSidewalk2=Polyhedron(ASidewalk2,bSidewalk2);
plot(PSidewalk2, 'Color', [.1,.6, .1], 'Alpha', .1);

end

function [params]=getparams()
params.ulowerBound=.08;
%grid size
params.MAX_X=2;
params.MAX_Y=2;
%time horizon
params.T=5;
%sample time
params.Ts=.1;
%discretization circle
params.NCircle=10;
%max. acceleration
params.amax=2;
params.vmax=3.333;
params.umax=.3;
%initial state pedestrian
params.x0Ped=[0; -2.5; 1.295; 0; 0; 0];
%initial state vehicle
params.x0Veh=[-35; 1.5; 11.11; 0];

%limits street
params.streetXMin=-40;
params.streetXMax=30;
%vehicle
params.vehicleLength=3;
params.vehicleWidth=1.4;


params.N=params.T/params.Ts;
params.options.wire=0;
params.veh_l=params.vehicleLength;
params.veh_b=params.vehicleWidth;
%params.veh_x=0;
params.vehicleTargetReached=0;
params.ped_l=1;
params.Ts=params.Ts;
params.m=1200;
params.d=.08;

params.n_cycles=1000;

params.Fy_max=10000;
params.c=0.7;
params.dist_safe=2*params.veh_l; % safety distance

%% Street
%params.street_xmin=params.streetXMin;
%params.street_xmax=params.streetXMax;
%params.street_ymin=-20;
%params.street_ymax=20;


%% Initial positions
%params.veh_xInit=4.5; % initial x position vehicle
%params.veh_yInit=-15; % initial y position vehicle
%params.ped_xInit=-1; % initial x position pedestrian
%params.ped_yInit=4; % initial y position pedestrian
%params.veh_vy_init=9;
%params.veh_ux_init=0;


params.nu=16; % control input time interval
params.vy_max=13;

params.diff_vy_max=2.78;
params.average_veloc_ped=1.83;
end

function discSys = getSystemDynamics(PAR)
A = [ 0, 1;...
    0, -PAR.d/PAR.m];
B = [0;
    1/PAR.m];
C = diag([1, 0]);
D = zeros(2,1);
sys=ss(A, B, C, D);
[discSys]=c2d(sys, PAR.Ts);
end
